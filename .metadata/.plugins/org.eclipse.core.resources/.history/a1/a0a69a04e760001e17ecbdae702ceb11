package com.movie;

public class MainMenu extends AbstractMenu{

	private static final MainMenu instance = new MainMenu(null);
	private static final String MAIN_MENU_TEXT = 
			"1. 영화 예매하기\n"+
			"2. 예매 확인하기\n"+
			"3. 예매 취소하기\n"+
			"4. 관리자 메뉴로 이동\n"+
			"q. 종료\n"+
			"메뉴를 선택하세요 : ";
			
	private MainMenu(Menu prevMenu) {
		super(MAIN_MENU_TEXT, prevMenu);
	}
	/* 현재 MainMenu가 상속받은 abstract public class AbstractMenu implements Menu 클래스에 두 가지를 매개변수로 받는 생성자가 있음!
	 * public AbstractMenu(String menuText, Menu prevMenu) {
		this.menuText = menuText;
		this.prevMenu = prevMenu;
	}
	근데 위에서 객체 생성할때 null값을 줬으니까 menuText는 MAIN_MENU_TEXT의 값을 받고 prevMenu는 null값을 가짐
	=> mainapp에서 호출되는 main.print에서 받는 변수도 여기서 받는 MAIN_MENU_TEXT가 들어감
	 * */
	public static MainMenu getInstance() {
		return instance;
	}
//static!!

	@Override
	public Menu next() {
		switch(sc.nextLine()) {
		case "2" :
			checkReservation();
			return this;
		case "4" :
			if(!checkAdminPassword()) { //비번 맞으면 false라서 if가 안돌고 비번 틀리면 !false = true니까 if가 돔
				System.out.println(">> wrong password");
				return this; //입력화면으로 다시 돌려보냄
			}
			AdminMenu adminMenu = AdminMenu.getInstance();
			adminMenu.setPrevMenu(this);
/* abstract public class AbstractMenu implements Menu 에서 
 * public void setPrevMenu(Menu prevMenu) {
		this.prevMenu = prevMenu;
	}
 * */
			return adminMenu;
			
		case "q" : return prevMenu; //null값이 들어가 잇는 상태
//		prevMenu가 protected로 되어잇어서 같은 패키지내에 상속받는 관계니까 불러올 수 있음
		default : return this;
		}
	}
	private void checkReservation() {
		System.out.println("발급 번호를 입력하세요 >>");
		try {
			
		} catch (Exception e) {
			// TODO: handle exception
		}
	}
	private boolean checkAdminPassword() {
		System.out.println("관리자 비밀번호를 입력하세요 >>");
		return "11".equals(sc.nextLine());
//		입력한 값과 admin1234와 같은지 확인하는 boolean 타입의 메서드 맞으면 ture, 틀리면 false
	}

}
